package Scent::TextAssembler;
use v5.14;
use warnings;
use parent qw(Scent::Assembler);

# Scent import
use Scent::Util qw(
  scFixedToString
  scEscapeString
);

=head1 NAME

Scent::TextAssembler - Assembler implementation that generates a Scent
Assembly text file.

=head1 SYNOPSIS

  # Construct the text assembler
  my $asm = Scent::TextAssembler->create("path/to/output.txt");
  
  # Run instructions (see Scent::Assembler documentation)
  ...
  
  # Finish up the output file and close it
  $asm->finish;

=head1 DESCRIPTION

C<Scent::Assembler> subclass that outputs all assembly instructions it
receives to a Scent Assembly output file.

This is useful for seeing how a Scent document is compiled into Scent
Assembly.  The file generated by this class can then be used by the
C<run()> method of the C<Scent::Assembler> superclass to play back all
the Scent Assembly instructions.

See the C<Scent::Assembler> superclass documentation for further
information.

=cut

# =================
# Private functions
# =================

# hyphDef(val)
# ------------
#
# If val is undef, return a string consisting of a hyphen.  Otherwise,
# return val as-is.
#
sub hyphDef {
  # Get parameters
  ($#_ == 0) or die;
  my $val = shift;
  
  # Replace with hyphen if undefined
  unless (defined $val) {
    $val = '-';
  }
  
  # Return possibly replaced value
  return $val;
}

=head1 CONSTRUCTOR

=over 4

=item B<create(path)>

Create a new text assembler instance.  C<path> is the path to the Scent
Assembly file to create.

After you are finished running all the instructions, you should call the
C<finish()> function on this subclass.

=cut

sub create {
  # Get parameters
  ($#_ == 1) or die;
  
  my $invocant = shift;
  my $class = ref($invocant) || $invocant;
  
  my $file_path = shift;
  (not ref($file_path)) or die;
  
  # Define the new object
  my $self = { };
  bless($self, $class);
  
  # The '_fh' property stores the file handle, or undef when the file is
  # closed
  open(my $fh, "> :encoding(UTF-8)", $file_path) or
    die "Failed to create output file '$file_path'!";
  $self->{'_fh'} = $fh;
  
  # Begin by writing the header
  print { $self->{'_fh'} } "scent-assembly 1.0\n";
  
  # Return the new object
  return $self;
}

=back

=head1 PUBLIC INSTANCE METHODS

These are specific to this subclass.  See the C<Scent::Assembler>
superclass for more functions.

=over 4

=item B<finish()>

Check that the assembler is in a valid state for closing the document,
then close the file.  You may not call this function more than once.
Attempting to use the object after calling this function will result in
an error.

=cut

sub finish {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Make sure this is a valid stopping point
  $self->canStop or
    die "Invalid stopping state at end of assembly!\n";
  
  # All set, so close the file
  close($self->{'_fh'}) or warn "Failed to close file";
  $self->{'_fh'} = undef;
}

=back

=head1 PROTECTED INSTANCE METHODS

Clients should not directly use these protected instance methods.
Instead, call the public instance methods defined by the superclass,
which will then check parameters and state and call through to the
protected methods defined by this sublcass.

=over 4

=item B<_font_standard(name, standard_name)>
=cut

sub _font_standard {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $font_name     = shift;
  my $standard_name = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "font_standard %s %s\n",
    $font_name, scEscapeString($standard_name);
}

=item B<_font_file(name, path)>
=cut

sub _font_file {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $font_name = shift;
  my $font_path = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "font_file %s %s\n",
    $font_name, scEscapeString($font_path);
}

=item B<_image_jpeg(name, path)>
=cut

sub _image_jpeg {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $image_name = shift;
  my $image_path = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "image_jpeg %s %s\n",
    $image_name, scEscapeString($image_path);
}

=item B<_image_png(name, path)>
=cut

sub _image_png {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $image_name = shift;
  my $image_path = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "image_png %s %s\n",
    $image_name, scEscapeString($image_path);
}

=item B<_begin_page()>
=cut

sub _begin_page {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "begin page\n";
}

=item B<_end_page()>
=cut

sub _end_page {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "end page\n";
}

=item B<_body()>
=cut

sub _body {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "body\n";
}

=item B<_dim(width, height)>
=cut

sub _dim {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $width  = shift;
  my $height = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "dim %s %s\n",
    scFixedToString($width), scFixedToString($height);
}

=item B<_bleed_box(min_x, min_y, max_x, max_y)>
=cut

sub _bleed_box {
  # Get self and parameters
  ($#_ == 4) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $min_x = shift;
  my $min_y = shift;
  my $max_x = shift;
  my $max_y = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "bleed_box %s %s %s %s\n",
    scFixedToString($min_x),
    scFixedToString($min_y),
    scFixedToString($max_x),
    scFixedToString($max_y);
}

=item B<_trim_box(min_x, min_y, max_x, max_y)>
=cut

sub _trim_box {
  # Get self and parameters
  ($#_ == 4) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $min_x = shift;
  my $min_y = shift;
  my $max_x = shift;
  my $max_y = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "trim_box %s %s %s %s\n",
    scFixedToString($min_x),
    scFixedToString($min_y),
    scFixedToString($max_x),
    scFixedToString($max_y);
}

=item B<_art_box(min_x, min_y, max_x, max_y)>
=cut

sub _art_box {
  # Get self and parameters
  ($#_ == 4) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $min_x = shift;
  my $min_y = shift;
  my $max_x = shift;
  my $max_y = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "art_box %s %s %s %s\n",
    scFixedToString($min_x),
    scFixedToString($min_y),
    scFixedToString($max_x),
    scFixedToString($max_y);
}

=item B<_view_rotate(mode)>
=cut

sub _view_rotate {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $mode = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "view_rotate %s\n",
    $mode;
}

=item B<_begin_path(stroke, fill, clip)>
=cut

sub _begin_path {
  # Get self and parameters
  ($#_ == 3) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $stroke = shift;
  my $fill   = shift;
  my $clip   = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "begin path %s\n",
    hyphDef($stroke),
    hyphDef($fill),
    hyphDef($clip);
}

=item B<_end_path()>
=cut

sub _end_path {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "end path\n";
}

=item B<_begin_text(clip)>
=cut

sub _begin_text {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $clip = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "begin text %s\n",
    hyphDef($clip);
}

=item B<_end_text()>
=cut

sub _end_text {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "end text\n";
}

=item B<_line_width(width)>
=cut

sub _line_width {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $width = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "line_width %s\n",
    scFixedToString($width);
}

=item B<_line_cap(style)>
=cut

sub _line_cap {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $style = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "line_cap %s\n",
    $style;
}

=item B<_line_join(style[, miter-ratio])>
=cut

sub _line_join {
  # Get self and parameters
  ($#_ >= 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  ($#_ >= 0) or die;
  my $style = shift;
  
  my $ratio = undef;
  if ($#_ >= 0) {
    $ratio = shift;
  }
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  if (defined $ratio) {
    printf { $self->{'_fh'} } "line_join %s %s\n",
      $style, scFixedToString($ratio);
  } else {
    printf { $self->{'_fh'} } "line_join %s\n",
      $style;
  }
}

=item B<_line_dash(phase, d1, g1, ... dn, gn)>
=cut

sub _line_dash {
  # Get self and phase parameter
  ($#_ >= 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  ($#_ >= 0) or die;
  my $phase = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "line_dash %s",
    scFixedToString($phase);
  for my $val (@_) {
    printf { $self->{'_fh'} } " %s",
      scFixedToString($val);
  }
  print "\n";
}

=item B<_line_undash()>
=cut

sub _line_undash {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "line_undash\n";
}

=item B<_stroke_color(color)>
=cut

sub _stroke_color {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $color = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "stroke_color %s\n",
    $color;
}

=item B<_fill_color(color)>
=cut

sub _fill_color {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $color = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "fill_color %s\n",
    $color;
}

=item B<_save()>
=cut

sub _save {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "save\n";
}

=item B<_restore()>
=cut

sub _restore {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "restore\n";
}

=item B<_matrix(a, b, c, d, e, f)>
=cut

sub _matrix {
  # Get self and parameters
  ($#_ == 6) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $a = shift;
  my $b = shift;
  my $c = shift;
  my $d = shift;
  my $e = shift;
  my $f = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "matrix %s %s %s %s %s %s\n",
    scFixedToString($a),
    scFixedToString($b),
    scFixedToString($c),
    scFixedToString($d),
    scFixedToString($e),
    scFixedToString($f);
}

=item B<_image(name)>
=cut

sub _image {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $image_name = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "image %s\n",
    $image_name;
}

=item B<_move(x, y)>
=cut

sub _move {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $x = shift;
  my $y = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "move %s %s\n",
    scFixedToString($x),
    scFixedToString($y);
}

=item B<_line(x2, y2)>
=cut

sub _line {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $x2 = shift;
  my $y2 = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "line %s %s\n",
    scFixedToString($x2),
    scFixedToString($y2);
}

=item B<_curve(x2, y2, x3, y3, x4, y4)>
=cut

sub _curve {
  # Get self and parameters
  ($#_ == 6) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $x2 = shift;
  my $y2 = shift;
  my $x3 = shift;
  my $y3 = shift;
  my $x4 = shift;
  my $y4 = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "curve %s %s %s %s %s %s\n",
    scFixedToString($x2),
    scFixedToString($y2),
    scFixedToString($x3),
    scFixedToString($y3),
    scFixedToString($x4),
    scFixedToString($y4);
}

=item B<_closePath()>
=cut

sub _closePath {
  # Get self
  ($#_ == 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  print { $self->{'_fh'} } "close\n";
}

=item B<_rect(x, y, width, height)>
=cut

sub _rect {
  # Get self and parameters
  ($#_ == 4) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $x      = shift;
  my $y      = shift;
  my $width  = shift;
  my $height = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "rect %s %s %s %s\n",
    scFixedToString($x),
    scFixedToString($y),
    scFixedToString($width),
    scFixedToString($height);
}

=item B<_cspace(extra)>
=cut

sub _cspace {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $extra = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "cspace %s\n",
    scFixedToString($extra);
}

=item B<_wspace(extra)>
=cut

sub _wspace {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $extra = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "wspace %s\n",
    scFixedToString($extra);
}

=item B<_hscale(percent)>
=cut

sub _hscale {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $pct = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "hscale %s\n",
    scFixedToString($pct);
}

=item B<_lead(distance)>
=cut

sub _lead {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $distance = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "lead %s\n",
    scFixedToString($distance);
}

=item B<_font(name, size)>
=cut

sub _font {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $font_name = shift;
  my $font_size = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "font %s %s\n",
    $font_name,
    scFixedToString($font_size);
}

=item B<_text_render(stroke, fill)>
=cut

sub _text_render {
  # Get self and parameters
  ($#_ == 2) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $stroke = shift;
  my $fill   = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "text_render %s %s\n",
    hyphDef($stroke),
    hyphDef($fill);
}

=item B<_rise(distance)>
=cut

sub _rise {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $distance = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "rise %s\n",
    scFixedToString($distance);
}

=item B<_advance([x, y])>
=cut

sub _advance {
  # Get self
  ($#_ >= 0) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $x = undef;
  my $y = undef;
  
  if ($#_ >= 0) {
    $x = shift;
    $y = shift;
  }
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  if (defined $x) {
    printf { $self->{'_fh'} } "advance %s %s\n",
      scFixedToString($x),
      scFixedToString($y);
  } else {
    print { $self->{'_fh'} } "advance\n";
  }
}

=item B<_writeText(string)>
=cut

sub _writeText {
  # Get self and parameters
  ($#_ == 1) or die;
  
  my $self = shift;
  (ref($self) and $self->isa(__PACKAGE__)) or die;
  
  my $str = shift;
  
  # Make sure the file is still open
  (defined $self->{'_fh'}) or die;
  
  # Print instruction
  printf { $self->{'_fh'} } "write %s\n",
    scEscapeString($str);
}

=back

=head1 AUTHOR

Noah Johnson E<lt>noah.johnson@loupmail.comE<gt>

=head1 COPYRIGHT

Copyright 2022 Multimedia Data Technology, Inc.

This program is free software.  You can redistribute it and/or modify it
under the same terms as Perl itself.

This program is also dual-licensed under the MIT license:

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut

# End with something that evaluates to true
1;
